<template>
  <div>
    <button type="button" @click="makeFetchRequest()">{{ apiCallData }}</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from "vue";

const apiCallData = ref();

const makeFetchRequest = () => {

  // get active tab and execute replaceTextElements on it
  chrome.tabs.query({ active: true, currentWindow: true }, function(tabs) {
    if (tabs && tabs.length > 0) {
      const activeTab = tabs[0];
      if (activeTab && activeTab.id) {
        console.log('Sending rewrite message to tab ' + activeTab.id);
        chrome.scripting.executeScript({
          target: { tabId: activeTab.id },
          func: replaceTextElements
        });
      } else {
        console.error("Error: Invalid tab object");
      }
    } else {
      console.error("Error: No active tabs found");
    }
  });

  function replaceTextElements() {
    
    // get all text elements (add or remove html tags as needed)
    const allParagraphs = document.querySelectorAll('p, figcaption, li');
    
    // just for printing
    let paragraphText = "";
    allParagraphs.forEach((paragraph) => {
      const paragraphContent = paragraph?.textContent?.trim();
      if (paragraphContent) {
        paragraphText += paragraphContent + "\n";
      }
    });
    console.log(paragraphText);

    paragraphText = "";

    // filtering out unwanted text
    const paragraphs = [];
    // remove all paragraphs that are in a header, footer, or nav element or parent class is navbox
    // Iterate over the selected elements and filter out unwanted ones
    allParagraphs.forEach((paragraph) => {
      const paragraphContent = paragraph?.textContent?.trim();
      
      // Check if the paragraph is within a <header>, <footer>, or <nav> element or has the class 'navbox'
      // can add more classes or tags to exclude here
        const isInHeaderFooterNavOrHasNavbox = paragraph.closest('header, footer, nav') || paragraph.closest('.navbox, .sidebar, .catlinks, .reflist');

      // If the paragraph isn't any of the above, add it to the final paragraphs array
      if (paragraphContent && isInHeaderFooterNavOrHasNavbox) {
        // this is a text element we do not want
      } else if (paragraphContent) {
        paragraphText += paragraphContent + "\n";
        paragraphs.push(paragraph);
      }
    });

    // console.log(paragraphText);

    // just for printing / debug
    paragraphs.forEach((paragraph) => {
      const paragraphContent = paragraph?.textContent?.trim();
      if (paragraphContent) {
        console.log(paragraphContent);
      }
    });

    // variable to store extracted paragraphs and their ids (ids are generated by us based on the order of the paragraphs)
    const extractedParagraphs = [];
    // variable to store extracted links and the paragraphs that use them
    const extractedLinks = {};

    // max characters defines upper limit on each group (needed to stay under the openai token limit)
    const maxCharacters = 3000;
    let totalCharacters = 0;

    paragraphs.forEach((paragraph, index) => {
      const paragraphContent = paragraph?.textContent?.trim();
      const paragraphId = index + 1;
      if (paragraphContent) {

        extractedParagraphs.push({
          id: paragraphId,
          content: paragraphContent
        });

      }

      // extract links from paragraph
      const links = paragraph.querySelectorAll('a');
      // find links within the paragraph and store their text and href in a dictionary that includes text, link, and paragraph ids
      links.forEach((link) => {
        const linkText = link?.textContent?.trim();
        const linkHref = link?.href;
        // if link already exists, add the paragraph id to the list of paragraphs that use it
        // otherwise, create a new entry in the dictionary
        if (linkText && linkHref) {
          if (extractedLinks[linkText]) {
            extractedLinks[linkText].paragraphId.push(paragraphId);
          } else {
            extractedLinks[linkText] = { link: linkHref, paragraphId: [paragraphId] };
          }
        }
      });

    });

    // at this point, we want to create groups of paragraphs to send to the LLM
    // we need to create groups to stay under the maximum token count
    // we also want to keep paragraphs together, so we can't split them up

    const groupedParagraphs = [];
    let currentGroup = [];
    extractedParagraphs.forEach((paragraph) => {
      const paragraphLength = paragraph.content.length;
      if (totalCharacters + paragraphLength > maxCharacters) {
        groupedParagraphs.push(currentGroup);
        currentGroup = [];
        totalCharacters = 0;
      }
      currentGroup.push(paragraph);
      totalCharacters += paragraphLength;
    });

    // push the last group since it didn't hit the token limit
    groupedParagraphs.push(currentGroup);

    // groupedParagraphs.forEach((group) => {
    //   console.log("Group")
    //   console.log(group);
    // });


    // cap groupedParagraphs at X groups (for testing, uncomment to do entire document)
    // groupedParagraphs.splice(3);

    
    // send groups to openai in a loop
    
    groupedParagraphs.forEach((group) => {

        // map elements to string to send to openai
      const extractedParagraphsString = group.map((paragraph) => {
        return `${paragraph.id}: ${paragraph.content}`;
      }).join("\n");

      console.log("Input:");
      console.log(extractedParagraphsString);

      // send to openai
      console.log("Sending group to OpenAI");
      const apiKey = "googoo"
      const apiUrl = "https://api.openai.com/v1/chat/completions"

      let prompt = "You are a bot that rewrites content. You maintain the format, rewriting the content in place, aiming for a similar number of characters for each section. Maintain the same format as the input, with ids. Keep the same ids. If there is a blank, leave it there. Do NOT add headers or anything else. Please rewrite this content to match a 1st grade reading level:\n"

      prompt += extractedParagraphsString;

      fetch(apiUrl, 
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization':'Bearer '+apiKey
        },
        body: JSON.stringify({
          "model": "gpt-3.5-turbo",
          "messages": [
            {
              role: "user",
              content: prompt
            }
          ],
          "temperature": 0.9
        })
      }
      ).then((response) => response.json()
      ).then((responseData) => {
        //console.log(responseData);
        const response = responseData["choices"][0]["message"]["content"]
        console.log("OpenAI Response:");
        console.log(response);
      if (response) {
        // get the paragraphs by splitting the response on newlines
        // TODO: This breaks if a page uses newlines within a single element
        // works fine for now though and it isn't too noticable so....
        const responseParagraphs = response.split("\n");
        console.log(responseParagraphs);
        // create dict of responseParagraph ids and text (parse the response)
        const responseParagraphsDict = {};
        responseParagraphs.forEach((responseParagraph) => {
          // id is at beginning of each paragraph, in the form 1: or 2: etc.
          const id = responseParagraph.split(': ')[0];
          const splitText = responseParagraph.split(': ');
          // rejoin the rest of the paragraph since there may be more than one colon
          let replacementText = splitText.slice(1).join(': '); 
          responseParagraphsDict[id] = replacementText;
        });
        // replace inner text of text nodes with the response text elements from OpenAI
        paragraphs.forEach((paragraph, index) => {
          // since paragraphs includes all paragraphs on the page, we need to check if the index is in the responseParagraphsDict for this specific openAI response
          if (responseParagraphsDict[index + 1]) {

            console.log("Original Paragraph " + index + ": " + paragraph.textContent);
            console.log("Replacement Paragraph: " + (index + 1) + ", " + responseParagraphsDict[index + 1])

            let replacementText = responseParagraphsDict[index + 1];

            // go through, and wherever the link text is re-used, replace it with a link
            for (const linkText in extractedLinks)
            {
              if(replacementText.includes(linkText))
              {
                // also check if it belongs to same paragraph
                // TODO: may need to add additional styling depending on page
                if(extractedLinks[linkText].paragraphId.includes(index + 1)){
                  replacementText = replacementText.replace(linkText, `<a href="${extractedLinks[linkText].link}">${linkText}</a>`)
                }
                
              }
            }

            // add the links that don't appear in the rewritten text below the paragraph
            const realLinks = Object.keys(extractedLinks).filter(linkText => extractedLinks[linkText].paragraphId.includes(index + 1) && !linkText.includes('[') && !linkText.includes(']') && !replacementText.includes(linkText));

            if(realLinks.length > 0) {
              const linksHtmtl = realLinks.map(linkText => `<a href="${extractedLinks[linkText].link}">${linkText}</a>`).join(', ');
              replacementText += "<br><br>Other Links: " + linksHtmtl;
            }
            
            // also add the references at the bottom
            const refLinks = Object.keys(extractedLinks).filter(linkText => extractedLinks[linkText].paragraphId.includes(index + 1) && linkText.includes('[') && linkText.includes(']'));
            if (refLinks.length > 0) {
              const refLinksHtml = refLinks.map(linkText => `<a href="${extractedLinks[linkText].link}">${linkText}</a>`).join(', ');
              replacementText += `<br>References: ${refLinksHtml}`;
            }

            replacementText += "<br>";

            // replace the text! 🤓
            paragraph.innerHTML = replacementText;

          }
        });
      }

      }).catch((error) => {
        console.log(error);
      });

    });

  }

};
</script>

<style scoped></style>
